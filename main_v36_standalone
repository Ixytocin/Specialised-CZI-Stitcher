# SPECIALISED CZI STITCHER v36.4 - FIXED LUT AND POSITIONS
# Single-file standalone with complete stitching integration
#
# Core features:
# 1. LUT/Color detection & application from OME-XML (RGBA format)
# 2. Pixel size scaling (0.345 µm correct)
# 3. Completion jingle
# 4. ImageJ stitching with linear blending
# 5. Single-pass metadata extraction (pixel size + ALL positions + colors)
# 6. 3D z-stack preservation in stitching output
#
# All metadata extracted in ONE pass - no repeated queries!

import os, time, shutil, re, array
from java.lang import System
from ij import IJ, ImagePlus, CompositeImage, WindowManager
from ij.plugin import HyperStackConverter
from ij.process import LUT
from loci.plugins import BF
from loci.plugins.in import ImporterOptions
from loci.formats import ImageReader, MetadataTools
from ij.gui import GenericDialog
from ij.io import FileSaver

VERSION = "v36.4"
MICRO = u"\u00b5"

# ==============================================================================
# PART 1: UTILITY FUNCTIONS
# ==============================================================================

def ensure_unicode(s):
    """Convert any string to unicode safely (Jython 2.7 compatible)"""
    if s is None:
        return None
    if isinstance(s, unicode):
        return s
    if hasattr(s, 'toString') and not isinstance(s, (str, bytes)):
        return unicode(s.toString())
    if isinstance(s, str):
        try:
            return s.decode('utf-8', 'replace')
        except:
            try:
                return s.decode('latin-1', 'replace')
            except:
                pass
    try:
        return unicode(s)
    except:
        return u""

def parse_all_stage_positions_from_xml(ome_xml):
    """Parse ALL StageLabel positions from OME-XML in single pass using regex.
    
    Returns list of (name, x_um, y_um, z_um) tuples.
    This is proven reliable pattern from v34.8 - parses all positions at once.
    """
    STAGELABEL_RE = re.compile(r'<(?:[A-Za-z0-9_]+:)?StageLabel\b([^>]*)/?>', re.IGNORECASE)
    ATTR_RE = re.compile(r'([A-Za-z_:][-A-Za-z0-9_:.]*)="([^"]*)"')
    
    positions = []
    if not ome_xml:
        return positions
    
    for m in STAGELABEL_RE.finditer(ome_xml):
        attr_blob = m.group(1)
        attrs = dict(ATTR_RE.findall(attr_blob))
        
        name = attrs.get('Name') or attrs.get('name') or ""
        x_str = attrs.get('X') or attrs.get('x')
        y_str = attrs.get('Y') or attrs.get('y')
        z_str = attrs.get('Z') or attrs.get('z')
        
        try:
            x = float(x_str) if x_str else 0.0
        except:
            x = 0.0
        try:
            y = float(y_str) if y_str else 0.0
        except:
            y = 0.0
        try:
            z = float(z_str) if z_str else 0.0
        except:
            z = 0.0
        
        positions.append((name, x, y, z))
    
    return positions

# ==============================================================================
# PART 2: OMEMetadataAccessor Class (Embedded)
# ==============================================================================

class OMEMetadataAccessor(object):
    """Accessor for OME-XML metadata from Bio-Formats reader"""
    
    def __init__(self, reader, verbose=False):
        """Initialize accessor with Bio-Formats reader"""
        self.reader = reader
        self.verbose = verbose
        
        if verbose:
            IJ.log(u"[CZI Stitcher {}]   [VERBOSE] Initializing OMEMetadataAccessor...".format(VERSION))
        
        # Get metadata store
        try:
            self.metadata = reader.getMetadataStore()
            if verbose:
                IJ.log(u"[CZI Stitcher {}]   [VERBOSE] Got metadata store: {}".format(
                    VERSION, type(self.metadata).__name__))
        except Exception as e:
            if verbose:
                IJ.log(u"[CZI Stitcher {}]   [VERBOSE] Failed to get metadata store: {}".format(VERSION, e))
            self.metadata = None
        
        # Cache OME-XML string
        self._ome_xml = None
        try:
            if self.metadata:
                if verbose:
                    IJ.log(u"[CZI Stitcher {}]   [VERBOSE] Dumping OME-XML...".format(VERSION))
                xml_str = self.metadata.dumpXML()
                self._ome_xml = ensure_unicode(xml_str)
                if verbose:
                    IJ.log(u"[CZI Stitcher {}]   [VERBOSE] OME-XML dumped: {} characters".format(
                        VERSION, len(self._ome_xml)))
        except Exception as e:
            if verbose:
                IJ.log(u"[CZI Stitcher {}]   [VERBOSE] Failed to dump OME-XML: {}".format(VERSION, e))
    
    def get_physical_size_x(self, series=0):
        """Get physical size X in micrometers"""
        try:
            if self.metadata:
                size = self.metadata.getPixelsPhysicalSizeX(series)
                if size is not None:
                    return float(size.value())
        except:
            pass
        
        # Fallback to XML regex
        if self._ome_xml:
            m = re.search(r'PhysicalSizeX\s*=\s*"([^"]+)"', self._ome_xml, re.IGNORECASE)
            if m:
                try:
                    return float(m.group(1))
                except:
                    pass
        return None
    
    def get_channel_count(self, series=0):
        """Get number of channels"""
        try:
            if self.metadata:
                return self.metadata.getChannelCount(series)
        except:
            pass
        return 0
    
    def get_channel_name(self, series, channel):
        """Get channel name"""
        try:
            if self.metadata:
                name = self.metadata.getChannelName(series, channel)
                if name:
                    return ensure_unicode(name)
        except:
            pass
        return None
    
    def get_channel_color(self, series, channel):
        """Get channel color as (R, G, B) tuple.
        
        Zeiss uses RGBA format stored as signed 32-bit int.
        Must convert to unsigned, then parse as hex string: RR GG BB AA
        """
        try:
            if self.metadata:
                color = self.metadata.getChannelColor(series, channel)
                if color is not None:
                    # Convert signed int to unsigned 32-bit
                    u = int(color.getValue()) & 0xFFFFFFFF
                    # Format as 8-digit hex: RRGGBBAA
                    hex8 = "%08X" % u
                    # Extract RGB components (ignore alpha)
                    r = int(hex8[0:2], 16)
                    g = int(hex8[2:4], 16)
                    b = int(hex8[4:6], 16)
                    return (r, g, b)
        except:
            pass
        return None

# ==============================================================================
# PART 3: CORE FUNCTIONS
# ==============================================================================

def log(msg):
    """Thread-safe logging"""
    IJ.log(ensure_unicode(msg))

def get_pixel_size(accessor, series=0):
    """Get pixel size in micrometers from accessor"""
    px_size = accessor.get_physical_size_x(series)
    if px_size and 0.01 <= px_size <= 50.0:
        return px_size
    return None

def apply_channel_luts(imp, accessor, series=0):
    """Apply channel colors from OME-XML to CompositeImage"""
    try:
        if not isinstance(imp, CompositeImage):
            if imp.getNChannels() > 1:
                imp = CompositeImage(imp, CompositeImage.COMPOSITE)
        
        n_channels = accessor.get_channel_count(series)
        if n_channels == 0:
            n_channels = imp.getNChannels()
        
        log(u"  Applying channel colors...")
        for c in range(min(n_channels, imp.getNChannels())):
            ch_name = accessor.get_channel_name(series, c)
            color_rgb = accessor.get_channel_color(series, c)
            
            if color_rgb:
                r, g, b = color_rgb
                log(u"    Ch{}: {} - RGB({}, {}, {})".format(c+1, ch_name or "Unknown", r, g, b))
                
                # Create LUT - MUST use Java byte arrays, not Python lists
                reds = array.array('b', [int(r * i / 255.0) for i in range(256)])
                greens = array.array('b', [int(g * i / 255.0) for i in range(256)])
                blues = array.array('b', [int(b * i / 255.0) for i in range(256)])
                
                lut = LUT(reds, greens, blues)
                imp.setC(c + 1)
                imp.setChannelLut(lut)
        
        log(u"  LUTs applied successfully")
        return imp
    
    except Exception as e:
        log(u"  WARNING: Could not apply LUTs: {}".format(e))
        return imp

def play_clear_jingle():
    """Play completion jingle using Java MIDI"""
    try:
        from javax.sound.midi import MidiSystem
        syn = MidiSystem.getSynthesizer()
        syn.open()
        ch = syn.getChannels()[0]
        ch.programChange(11)  # Music box
        
        notes = [64, 68, 72]  # E, G#, C
        velocities = [100, 80, 60]
        
        for n, v in zip(notes, velocities):
            ch.noteOn(n, v)
            ch.noteOn(n-20, max(0, v-10))
            ch.noteOn(n+10, max(0, v-10))
            time.sleep(0.2)
        
        time.sleep(0.4)
        for n in notes:
            ch.noteOff(n)
        syn.close()
    except Exception as e:
        log(u"  Jingle failed: {}".format(e))

def extract_tiles_and_positions(czi_path, temp_dir, config, reader, accessor, px_size, all_positions):
    """Extract all tiles from CZI file with positions from pre-parsed list.
    
    Returns (tiles_2d, tiles_3d) where:
        tiles_2d: List of (filename, idx, x_um, y_um, z_um) for 2D projections
        tiles_3d: List of (filename_3d, idx, x_um, y_um, z_um, n_slices) for 3D stacks
    
    Args:
        all_positions: List of (name, x_um, y_um, z_um) from parse_all_stage_positions_from_xml()
    """
    verbose = config.get('verbose', False)
    
    try:
        # Open all series (tiles) from CZI
        options = ImporterOptions()
        options.setId(czi_path)
        options.setStitchTiles(False)  # Keep tiles separate
        options.setOpenAllSeries(True)
        options.setVirtual(False)
        
        imps = BF.openImagePlus(options)
        
        if not imps or len(imps) == 0:
            log(u"  ERROR: No tiles found in file")
            return [], []
        
        log(u"  Found {} tile(s)".format(len(imps)))
        
        tiles_2d = []  # For stitching registration (2D projections)
        tiles_3d = []  # For final 3D stitching
        
        # Debug position count
        if verbose:
            log(u"  [VERBOSE] Parsed {} positions from XML, {} tiles in file".format(
                len(all_positions), len(imps)))
        
        # Process each tile
        for i, tile_imp in enumerate(imps):
            # Get position from pre-parsed list (NO API CALLS HERE)
            if i < len(all_positions):
                name, x_um, y_um, z_um = all_positions[i]
                # Check if XML position is valid (not 0,0)
                if x_um != 0.0 or y_um != 0.0:
                    source = "from XML"
                else:
                    # XML had 0,0 - use calculated
                    x_um = float(i * tile_imp.getWidth() * px_size)
                    source = "calculated (XML was zero)"
            else:
                # No XML position for this tile index
                x_um = float(i * tile_imp.getWidth() * px_size)
                y_um = 0.0
                z_um = 0.0
                source = "calculated (no XML entry)"
            
            if verbose:
                log(u"    Tile {}: pos=({:.2f}, {:.2f}, {:.2f}) µm [{}]".format(
                    i, x_um, y_um, z_um, source))
            
            # Handle z-stacks: Save BOTH 3D and 2D MIP (v31.16h pattern)
            if tile_imp.getNSlices() > 1:
                n_slices = tile_imp.getNSlices()
                if verbose:
                    log(u"      Z-stack: {} slices → saving 3D + MIP".format(n_slices))
                
                # Save original 3D stack
                tile_3d_filename = "S{:03d}_3D.tif".format(i)
                tile_3d_path = os.path.join(temp_dir, tile_3d_filename)
                fs_3d = FileSaver(tile_imp)
                fs_3d.saveAsTiffStack(tile_3d_path)
                tiles_3d.append((tile_3d_filename, i, x_um, y_um, z_um, n_slices))
                
                # Create and save MIP for registration
                IJ.run(tile_imp, "Z Project...", "projection=[Max Intensity]")
                proj_imp = WindowManager.getCurrentImage()
                
                if proj_imp is not None and proj_imp.getNSlices() == 1:
                    tile_2d_filename = "S{:03d}_MIP.tif".format(i)
                    tile_2d_path = os.path.join(temp_dir, tile_2d_filename)
                    fs_2d = FileSaver(proj_imp)
                    fs_2d.saveAsTiff(tile_2d_path)
                    tiles_2d.append((tile_2d_filename, i, x_um, y_um, z_um))
                    proj_imp.close()
                    if verbose:
                        log(u"      Saved: {} (3D) + {} (MIP)".format(tile_3d_filename, tile_2d_filename))
                else:
                    # Fallback: use first slice as 2D
                    if verbose:
                        log(u"      WARNING: Projection failed, using first slice")
                    if proj_imp is not None:
                        proj_imp.close()
                    tile_imp.setSlice(1)
                    IJ.run(tile_imp, "Duplicate...", "duplicate")
                    dup_imp = WindowManager.getCurrentImage()
                    tile_2d_filename = "S{:03d}_MIP.tif".format(i)
                    tile_2d_path = os.path.join(temp_dir, tile_2d_filename)
                    fs_2d = FileSaver(dup_imp)
                    fs_2d.saveAsTiff(tile_2d_path)
                    tiles_2d.append((tile_2d_filename, i, x_um, y_um, z_um))
                    dup_imp.close()
                
                tile_imp.close()
            else:
                # Single slice: use same file for both 2D and 3D
                tile_filename = "S{:03d}_2D.tif".format(i)
                tile_path = os.path.join(temp_dir, tile_filename)
                fs = FileSaver(tile_imp)
                fs.saveAsTiff(tile_path)
                tiles_2d.append((tile_filename, i, x_um, y_um, z_um))
                tiles_3d.append((tile_filename, i, x_um, y_um, z_um, 1))
                tile_imp.close()
                if verbose:
                    log(u"      Single slice: saved as {}".format(tile_filename))
        
        # Don't close reader here - managed by caller
        return tiles_2d, tiles_3d
    
    except Exception as e:
        log(u"  ERROR extracting tiles: {}".format(e))
        import traceback
        traceback.print_exc()
        return [], []

def create_tile_configuration(tiles, config_path, px_size):
    """Create TileConfiguration.txt for stitching plugin"""
    try:
        with open(config_path, 'w') as f:
            f.write("# Define the number of dimensions we are working on\n")
            f.write("dim = 2\n\n")
            
            for tile_filename, idx, x_um, y_um, z_um in tiles:
                # Convert µm to pixels
                x_px = x_um / px_size
                y_px = y_um / px_size
                
                f.write("{}; ; ({:.2f}, {:.2f})\n".format(tile_filename, x_px, y_px))
        
        return True
    except Exception as e:
        log(u"  ERROR creating tile configuration: {}".format(e))
        return False

def run_stitching_plugin(temp_dir, config):
    """Run ImageJ stitching plugin for 2D"""
    verbose = config.get('verbose', False)
    
    try:
        tile_config = os.path.join(temp_dir, "TileConfiguration.txt")
        
        # Build stitching command
        params = (
            "type=[Positions from file] "
            "order=[Defined by TileConfiguration] "
            "directory=[{}] "
            "layout_file=[TileConfiguration.txt] "
            "fusion_method=[Linear Blending] "
            "regression_threshold=0.30 "
            "max/avg_displacement_threshold=2.50 "
            "absolute_displacement_threshold=3.50 "
            "compute_overlap "
            "subpixel_accuracy "
            "computation_parameters=[Save memory (but be slower)] "
            "image_output=[Fuse and display]"
        ).format(temp_dir)
        
        if verbose:
            log(u"  [VERBOSE] Running 2D stitching plugin...")
        
        IJ.run("Grid/Collection stitching", params)
        
        # Get result
        result_imp = WindowManager.getCurrentImage()
        if result_imp is None:
            log(u"  ERROR: Stitching plugin did not produce an image")
            return None
        
        if verbose:
            log(u"  [VERBOSE] 2D stitching complete: {} x {} x {}".format(
                result_imp.getWidth(), result_imp.getHeight(), result_imp.getNSlices()))
        
        return result_imp
    
    except Exception as e:
        log(u"  ERROR in 2D stitching: {}".format(e))
        import traceback
        traceback.print_exc()
        return None

def create_3d_tile_configuration(temp_dir, tiles_3d, px_size):
    """Create TileConfiguration_3D.txt using registered positions from 2D stitching.
    
    This implements the v31.16h pattern:
    1. Read TileConfiguration.registered.txt from 2D stitching
    2. Map 2D positions to 3D tile filenames
    3. Create TileConfiguration_3D.txt with dim=3 and z=0.0
    """
    try:
        # Path to registered positions from 2D stitching
        reg_config = os.path.join(temp_dir, "TileConfiguration.registered.txt")
        orig_config = os.path.join(temp_dir, "TileConfiguration.txt")
        config_3d = os.path.join(temp_dir, "TileConfiguration_3D.txt")
        
        # Use registered positions if available, otherwise original
        source_config = reg_config if os.path.exists(reg_config) else orig_config
        
        if not os.path.exists(source_config):
            log(u"  ERROR: No configuration file found at {}".format(source_config))
            return False
        
        # Parse positions from source config
        positions = []
        with open(source_config, 'r') as f:
            for line in f:
                line = line.strip()
                if '.tif' in line and '(' in line and ')' in line:
                    # Extract coordinates from line like: "S000_MIP.tif; ; (123.45, 678.90)"
                    match = re.search(r'\(([^,]+),\s*([^)]+)\)', line)
                    if match:
                        x = float(match.group(1))
                        y = float(match.group(2))
                        positions.append((x, y))
        
        if len(positions) == 0:
            log(u"  ERROR: No positions found in {}".format(source_config))
            return False
        
        # Create 3D configuration
        with open(config_3d, 'w') as f:
            f.write("# Generated 3D configuration from 2D registration\n")
            f.write("dim = 3\n\n")
            
            for i, (filename_3d, idx, x_um, y_um, z_um, n_slices) in enumerate(tiles_3d):
                # Use registered position if available, otherwise original
                if i < len(positions):
                    x_px, y_px = positions[i]
                else:
                    # Fallback to original position
                    x_px = x_um / px_size
                    y_px = y_um / px_size
                
                # Write with z=0.0 (all tiles at same z-plane)
                f.write("{}; ; ({:.6f}, {:.6f}, 0.0)\n".format(filename_3d, x_px, y_px))
        
        return True
    
    except Exception as e:
        log(u"  ERROR creating 3D tile configuration: {}".format(e))
        import traceback
        traceback.print_exc()
        return False

def run_stitching_plugin_3d(temp_dir, config):
    """Run ImageJ stitching plugin for 3D stacks using pre-computed positions"""
    verbose = config.get('verbose', False)
    
    try:
        # Build stitching command for 3D
        params = (
            "type=[Positions from file] "
            "order=[Defined by TileConfiguration] "
            "directory=[{}] "
            "layout_file=[TileConfiguration_3D.txt] "
            "fusion_method=[Linear Blending] "
            "subpixel_accuracy "
            "computation_parameters=[Save memory (but be slower)] "
            "image_output=[Fuse and display]"
        ).format(temp_dir)
        
        if verbose:
            log(u"  [VERBOSE] Running 3D stitching plugin...")
        
        IJ.run("Grid/Collection stitching", params)
        
        # Get result
        result_imp = WindowManager.getCurrentImage()
        if result_imp is None:
            log(u"  ERROR: 3D stitching plugin did not produce an image")
            return None
        
        if verbose:
            log(u"  [VERBOSE] 3D stitching complete: {} x {} x {}".format(
                result_imp.getWidth(), result_imp.getHeight(), result_imp.getNSlices()))
        
        return result_imp
    
    except Exception as e:
        log(u"  ERROR in 3D stitching: {}".format(e))
        import traceback
        traceback.print_exc()
        return None

def process_czi_file(czi_path, config):
    """Process single CZI file with complete pipeline"""
    verbose = config.get('verbose', False)
    base_name = os.path.splitext(os.path.basename(czi_path))[0]
    
    log(u"")
    log(u"[1/1] Processing: {}".format(os.path.basename(czi_path)))
    
    start_time = time.time()
    
    # Create temp directory
    temp_dir = os.path.join(config['output_dir'], "temp_tiles_{}".format(int(time.time())))
    if not os.path.exists(temp_dir):
        os.makedirs(temp_dir)
    
    try:
        # ====================================================================
        # CRITICAL: SINGLE-PASS METADATA EXTRACTION
        # Extract pixel size, ALL positions, and colors in ONE operation
        # ====================================================================
        
        if verbose:
            log(u"  [VERBOSE] Opening file and extracting metadata...")
        
        metadata = MetadataTools.createOMEXMLMetadata()
        reader = ImageReader()
        reader.setMetadataStore(metadata)
        reader.setId(czi_path)
        accessor = OMEMetadataAccessor(reader, verbose=verbose)
        
        # Extract ALL metadata at once
        px_size = get_pixel_size(accessor, series=0)
        if not px_size:
            px_size = 0.345  # Fallback
        
        all_positions = parse_all_stage_positions_from_xml(accessor._ome_xml)
        
        if verbose:
            log(u"  [VERBOSE] Single-pass metadata extraction complete:")
            log(u"    Pixel size: {} µm".format(px_size))
            log(u"    Positions: {} StageLabels parsed from OME-XML".format(len(all_positions)))
            log(u"    Colors: Cached in accessor for later use")
        
        # Extract tiles using cached metadata (returns both 2D and 3D)
        log(u"  Extracting tiles...")
        tiles_2d, tiles_3d = extract_tiles_and_positions(czi_path, temp_dir, config, reader, accessor, px_size, all_positions)
        
        if not tiles_2d or len(tiles_2d) == 0:
            log(u"  ERROR: No tiles extracted")
            reader.close()
            return
        
        if len(tiles_2d) == 1:
            # Single tile - just apply metadata (use 3D if available)
            log(u"  Single tile - skipping stitching")
            if tiles_3d and len(tiles_3d) > 0:
                tile_path = os.path.join(temp_dir, tiles_3d[0][0])
            else:
                tile_path = os.path.join(temp_dir, tiles_2d[0][0])
            imp = IJ.openImage(tile_path)
            
            # Apply calibration
            cal = imp.getCalibration()
            cal.pixelWidth = px_size
            cal.pixelHeight = px_size
            cal.setUnit("um")
            imp.setCalibration(cal)
            log(u"  Calibration: {} {}m/pixel".format(px_size, MICRO))
            
            # Apply colors
            if imp.getNChannels() > 1:
                imp = apply_channel_luts(imp, accessor, series=0)
        else:
            # Multi-tile - stitch (v31.16h 3D workflow)
            log(u"  Creating 2D tile configuration for registration...")
            create_tile_configuration(tiles_2d, os.path.join(temp_dir, "TileConfiguration.txt"), px_size)
            
            log(u"  Stitching {} 2D projections for registration...".format(len(tiles_2d)))
            imp_2d = run_stitching_plugin(temp_dir, config)
            
            if imp_2d is None:
                log(u"  ERROR: 2D stitching failed")
                reader.close()
                return
            
            # Close 2D result (we only needed it for registration)
            imp_2d.close()
            
            # Check if we have 3D stacks to stitch
            has_3d = tiles_3d and any(t[5] > 1 for t in tiles_3d if len(t) > 5)
            
            if has_3d:
                # Transfer registered positions to 3D configuration
                log(u"  Transferring registration to 3D stacks...")
                if not create_3d_tile_configuration(temp_dir, tiles_3d, px_size):
                    log(u"  ERROR: Failed to create 3D configuration")
                    reader.close()
                    return
                
                log(u"  Stitching {} 3D stacks...".format(len(tiles_3d)))
                imp = run_stitching_plugin_3d(temp_dir, config)
                
                if imp is None:
                    log(u"  WARNING: 3D stitching failed, using 2D result")
                    # Reopen 2D result as fallback
                    imp = run_stitching_plugin(temp_dir, config)
            else:
                # No 3D stacks, reopen 2D result
                imp = run_stitching_plugin(temp_dir, config)
            
            if imp is None:
                log(u"  ERROR: Stitching failed")
                reader.close()
                return
            
            # Apply calibration
            cal = imp.getCalibration()
            cal.pixelWidth = px_size
            cal.pixelHeight = px_size
            cal.setUnit("um")
            imp.setCalibration(cal)
            log(u"  Calibration applied: {} {}m/pixel".format(px_size, MICRO))
            
            # Apply colors
            if imp.getNChannels() > 1:
                imp = apply_channel_luts(imp, accessor, series=0)
        
        # Close reader
        reader.close()
        
        # Set title
        imp.setTitle(base_name + "_stitched")
        
        # Show and/or save
        if config.get('show_result', True):
            imp.show()
            log(u"  Result displayed")
        
        if config.get('save_result', True):
            output_path = os.path.join(config['output_dir'], base_name + "_stitched.tif")
            fs = FileSaver(imp)
            if imp.getNSlices() > 1:
                fs.saveAsTiffStack(output_path)
            else:
                fs.saveAsTiff(output_path)
            log(u"  Saved: {}".format(os.path.basename(output_path)))
        
        elapsed = time.time() - start_time
        log(u"  Complete! ({:.1f} seconds)".format(elapsed))
    
    except Exception as e:
        log(u"  ERROR: {}".format(e))
        import traceback
        traceback.print_exc()
    
    finally:
        # Cleanup
        if config.get('cleanup_temp', True):
            try:
                if os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
                    if verbose:
                        log(u"  [VERBOSE] Cleaned up temp directory")
            except:
                pass

# ==============================================================================
# PART 4: MAIN DIALOG AND EXECUTION
# ==============================================================================

def main():
    """Main entry point"""
    
    log(u"")
    log(u"SPECIALISED CZI STITCHER {}".format(VERSION))
    log(u"Single-file standalone with complete stitching")
    log(u"Core: LUTs + Scaling + Positions + Stitching + Jingle")
    log(u"")
    
    # Create dialog
    gd = GenericDialog("CZI Stitcher {}".format(VERSION))
    gd.addMessage("=== DIRECTORIES ===")
    gd.addDirectoryField("Input (CZI files):", os.path.expanduser("~"), 50)
    gd.addDirectoryField("Output:", os.path.expanduser("~"), 50)
    
    gd.addMessage("\n=== OPTIONS ===")
    gd.addCheckbox("Show stitched result", True)
    gd.addCheckbox("Save stitched result", True)
    gd.addCheckbox("Cleanup temp files", True)
    gd.addCheckbox("Verbose mode (detailed progress)", False)
    gd.addCheckbox("Play completion jingle", False)
    
    gd.showDialog()
    
    if gd.wasCanceled():
        return
    
    # Get parameters
    input_dir = gd.getNextString()
    output_dir = gd.getNextString()
    show_result = int(gd.getNextBoolean()) == 1
    save_result = int(gd.getNextBoolean()) == 1
    cleanup_temp = int(gd.getNextBoolean()) == 1
    verbose = int(gd.getNextBoolean()) == 1
    play_jingle = int(gd.getNextBoolean()) == 1
    
    # Validate directories
    if not os.path.isdir(input_dir):
        IJ.error("Input directory does not exist")
        return
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Build config
    config = {
        'input_dir': input_dir,
        'output_dir': output_dir,
        'show_result': show_result,
        'save_result': save_result,
        'cleanup_temp': cleanup_temp,
        'verbose': verbose,
        'play_jingle': play_jingle
    }
    
    # Find CZI files
    czi_files = [f for f in os.listdir(input_dir) if f.lower().endswith('.czi')]
    
    if len(czi_files) == 0:
        IJ.error("No CZI files found in input directory")
        return
    
    log(u"============================================================")
    log(u"STITCHING SESSION START")
    log(u"============================================================")
    log(u"Input:  {}".format(input_dir))
    log(u"Output: {}".format(output_dir))
    log(u"")
    
    if verbose:
        log(u"[VERBOSE] Configuration:")
        log(u"  Show result: {}".format(show_result))
        log(u"  Save result: {}".format(save_result))
        log(u"  Cleanup temp: {}".format(cleanup_temp))
        log(u"  Jingle: {}".format(play_jingle))
        log(u"")
    
    log(u"Found {} CZI file(s)".format(len(czi_files)))
    
    # Process files
    session_start = time.time()
    
    for czi_file in czi_files:
        czi_path = os.path.join(input_dir, czi_file)
        process_czi_file(czi_path, config)
    
    session_elapsed = time.time() - session_start
    
    log(u"")
    log(u"============================================================")
    log(u"ALL FILES PROCESSED")
    log(u"============================================================")
    log(u"Total time: {:.1f} seconds".format(session_elapsed))
    log(u"")
    
    # Play jingle if enabled
    if play_jingle:
        try:
            play_clear_jingle()
            log(u"Processing complete!")
        except:
            log(u"Processing complete! (jingle failed)")
    else:
        log(u"Processing complete!")

# Run main
if __name__ == "__main__" or __name__ == "__builtin__":
    main()
