# SPECIALISED CZI STITCHER v36.3 - FINAL STABLE VERSION
# Single-file standalone with complete stitching integration
#
# Core features:
# 1. LUT/Color detection & application from OME-XML (RGBA format)
# 2. Pixel size scaling (0.345 µm correct)
# 3. Completion jingle
# 4. ImageJ stitching with linear blending
# 5. Single-pass metadata extraction (pixel size + ALL positions + colors)
# 6. 3D z-stack preservation in stitching output
#
# All metadata extracted in ONE pass - no repeated queries!

import os, time, shutil, re
from java.lang import System
from ij import IJ, ImagePlus, CompositeImage, WindowManager
from ij.plugin import HyperStackConverter
from ij.process import LUT
from loci.plugins import BF
from loci.plugins.in import ImporterOptions
from loci.formats import ImageReader, MetadataTools
from ij.gui import GenericDialog
from ij.io import FileSaver

MICRO = u"\u00b5"

# ==============================================================================
# PART 1: UTILITY FUNCTIONS
# ==============================================================================

def ensure_unicode(s):
    """Convert any string to unicode safely (Jython 2.7 compatible)"""
    if s is None:
        return None
    if isinstance(s, unicode):
        return s
    if hasattr(s, 'toString') and not isinstance(s, (str, bytes)):
        return unicode(s.toString())
    if isinstance(s, str):
        try:
            return s.decode('utf-8', 'replace')
        except:
            try:
                return s.decode('latin-1', 'replace')
            except:
                pass
    try:
        return unicode(s)
    except:
        return u""

def parse_all_stage_positions_from_xml(ome_xml):
    """Parse ALL StageLabel positions from OME-XML in single pass using regex.
    
    Returns list of (name, x_um, y_um, z_um) tuples.
    This is proven reliable pattern from v34.8 - parses all positions at once.
    """
    STAGELABEL_RE = re.compile(r'<(?:[A-Za-z0-9_]+:)?StageLabel\b([^>]*)/?>', re.IGNORECASE)
    ATTR_RE = re.compile(r'([A-Za-z_:][-A-Za-z0-9_:.]*)="([^"]*)"')
    
    positions = []
    if not ome_xml:
        return positions
    
    for m in STAGELABEL_RE.finditer(ome_xml):
        attr_blob = m.group(1)
        attrs = dict(ATTR_RE.findall(attr_blob))
        
        name = attrs.get('Name') or attrs.get('name') or ""
        x_str = attrs.get('X') or attrs.get('x')
        y_str = attrs.get('Y') or attrs.get('y')
        z_str = attrs.get('Z') or attrs.get('z')
        
        try:
            x = float(x_str) if x_str else 0.0
        except:
            x = 0.0
        try:
            y = float(y_str) if y_str else 0.0
        except:
            y = 0.0
        try:
            z = float(z_str) if z_str else 0.0
        except:
            z = 0.0
        
        positions.append((name, x, y, z))
    
    return positions

# ==============================================================================
# PART 2: OMEMetadataAccessor Class (Embedded)
# ==============================================================================

class OMEMetadataAccessor(object):
    """Accessor for OME-XML metadata from Bio-Formats reader"""
    
    def __init__(self, reader, verbose=False):
        """Initialize accessor with Bio-Formats reader"""
        self.reader = reader
        self.verbose = verbose
        
        if verbose:
            IJ.log(u"[CZI Stitcher v36.3]   [VERBOSE] Initializing OMEMetadataAccessor...")
        
        # Get metadata store
        try:
            self.metadata = reader.getMetadataStore()
            if verbose:
                IJ.log(u"[CZI Stitcher v36.3]   [VERBOSE] Got metadata store: {}".format(
                    type(self.metadata).__name__))
        except Exception as e:
            if verbose:
                IJ.log(u"[CZI Stitcher v36.3]   [VERBOSE] Failed to get metadata store: {}".format(e))
            self.metadata = None
        
        # Cache OME-XML string
        self._ome_xml = None
        try:
            if self.metadata:
                if verbose:
                    IJ.log(u"[CZI Stitcher v36.3]   [VERBOSE] Dumping OME-XML...")
                xml_str = self.metadata.dumpXML()
                self._ome_xml = ensure_unicode(xml_str)
                if verbose:
                    IJ.log(u"[CZI Stitcher v36.3]   [VERBOSE] OME-XML dumped: {} characters".format(
                        len(self._ome_xml)))
        except Exception as e:
            if verbose:
                IJ.log(u"[CZI Stitcher v36.3]   [VERBOSE] Failed to dump OME-XML: {}".format(e))
    
    def get_physical_size_x(self, series=0):
        """Get physical size X in micrometers"""
        try:
            if self.metadata:
                size = self.metadata.getPixelsPhysicalSizeX(series)
                if size is not None:
                    return float(size.value())
        except:
            pass
        
        # Fallback to XML regex
        if self._ome_xml:
            m = re.search(r'PhysicalSizeX\s*=\s*"([^"]+)"', self._ome_xml, re.IGNORECASE)
            if m:
                try:
                    return float(m.group(1))
                except:
                    pass
        return None
    
    def get_channel_count(self, series=0):
        """Get number of channels"""
        try:
            if self.metadata:
                return self.metadata.getChannelCount(series)
        except:
            pass
        return 0
    
    def get_channel_name(self, series, channel):
        """Get channel name"""
        try:
            if self.metadata:
                name = self.metadata.getChannelName(series, channel)
                if name:
                    return ensure_unicode(name)
        except:
            pass
        return None
    
    def get_channel_color(self, series, channel):
        """Get channel color as (R, G, B) tuple.
        
        Zeiss uses RGBA format stored as signed 32-bit int.
        Must convert to unsigned, then parse as hex string: RR GG BB AA
        """
        try:
            if self.metadata:
                color = self.metadata.getChannelColor(series, channel)
                if color is not None:
                    # Convert signed int to unsigned 32-bit
                    u = int(color.getValue()) & 0xFFFFFFFF
                    # Format as 8-digit hex: RRGGBBAA
                    hex8 = "%08X" % u
                    # Extract RGB components (ignore alpha)
                    r = int(hex8[0:2], 16)
                    g = int(hex8[2:4], 16)
                    b = int(hex8[4:6], 16)
                    return (r, g, b)
        except:
            pass
        return None

# ==============================================================================
# PART 3: CORE FUNCTIONS
# ==============================================================================

def log(msg):
    """Thread-safe logging"""
    IJ.log(ensure_unicode(msg))

def get_pixel_size(accessor, series=0):
    """Get pixel size in micrometers from accessor"""
    px_size = accessor.get_physical_size_x(series)
    if px_size and 0.01 <= px_size <= 50.0:
        return px_size
    return None

def apply_channel_luts(imp, accessor, series=0):
    """Apply channel colors from OME-XML to CompositeImage"""
    try:
        if not isinstance(imp, CompositeImage):
            if imp.getNChannels() > 1:
                imp = CompositeImage(imp, CompositeImage.COMPOSITE)
        
        n_channels = accessor.get_channel_count(series)
        if n_channels == 0:
            n_channels = imp.getNChannels()
        
        log(u"  Applying channel colors...")
        for c in range(min(n_channels, imp.getNChannels())):
            ch_name = accessor.get_channel_name(series, c)
            color_rgb = accessor.get_channel_color(series, c)
            
            if color_rgb:
                r, g, b = color_rgb
                log(u"    Ch{}: {} - RGB({}, {}, {})".format(c+1, ch_name or "Unknown", r, g, b))
                
                # Create LUT
                reds = [int(r * i / 255.0) for i in range(256)]
                greens = [int(g * i / 255.0) for i in range(256)]
                blues = [int(b * i / 255.0) for i in range(256)]
                
                lut = LUT(reds, greens, blues)
                imp.setC(c + 1)
                imp.setChannelLut(lut)
        
        log(u"  LUTs applied successfully")
        return imp
    
    except Exception as e:
        log(u"  WARNING: Could not apply LUTs: {}".format(e))
        return imp

def play_clear_jingle():
    """Play completion jingle using Java MIDI"""
    try:
        from javax.sound.midi import MidiSystem
        syn = MidiSystem.getSynthesizer()
        syn.open()
        ch = syn.getChannels()[0]
        ch.programChange(11)  # Music box
        
        notes = [64, 68, 72]  # E, G#, C
        velocities = [100, 80, 60]
        
        for n, v in zip(notes, velocities):
            ch.noteOn(n, v)
            ch.noteOn(n-20, max(0, v-10))
            ch.noteOn(n+10, max(0, v-10))
            time.sleep(0.2)
        
        time.sleep(0.4)
        for n in notes:
            ch.noteOff(n)
        syn.close()
    except Exception as e:
        log(u"  Jingle failed: {}".format(e))

def extract_tiles_and_positions(czi_path, temp_dir, config, reader, accessor, px_size, all_positions):
    """Extract all tiles from CZI file with positions from pre-parsed list.
    
    Args:
        all_positions: List of (name, x_um, y_um, z_um) from parse_all_stage_positions_from_xml()
    """
    verbose = config.get('verbose', False)
    
    try:
        # Open all series (tiles) from CZI
        options = ImporterOptions()
        options.setId(czi_path)
        options.setStitchTiles(False)  # Keep tiles separate
        options.setOpenAllSeries(True)
        options.setVirtual(False)
        
        imps = BF.openImagePlus(options)
        
        if not imps or len(imps) == 0:
            log(u"  ERROR: No tiles found in file")
            return []
        
        log(u"  Found {} tile(s)".format(len(imps)))
        
        tiles = []
        tiles_3d = []  # Store 3D stacks for later reconstruction
        
        # Process each tile
        for i, tile_imp in enumerate(imps):
            tile_filename = "tile_{:04d}.tif".format(i)
            tile_path = os.path.join(temp_dir, tile_filename)
            
            # Get position from pre-parsed list (NO API CALLS HERE)
            if i < len(all_positions):
                name, x_um, y_um, z_um = all_positions[i]
                source = "from XML"
            else:
                # Fallback if positions missing
                x_um = float(i * tile_imp.getWidth() * px_size)
                y_um = 0.0
                z_um = 0.0
                source = "calculated"
            
            if verbose:
                log(u"    Tile {}: pos=({:.2f}, {:.2f}, {:.2f}) µm [{}]".format(
                    i, x_um, y_um, z_um, source))
            
            # Handle z-stacks: Project for stitching, but preserve original
            if tile_imp.getNSlices() > 1:
                if verbose:
                    log(u"      Z-stack detected: {} slices".format(tile_imp.getNSlices()))
                
                # Save original 3D stack for later
                tile_3d_path = os.path.join(temp_dir, "tile_{:04d}_3d.tif".format(i))
                fs_3d = FileSaver(tile_imp)
                fs_3d.saveAsTiffStack(tile_3d_path)
                tiles_3d.append((i, tile_3d_path, tile_imp.getNSlices()))
                
                # Create projection for stitching
                IJ.run(tile_imp, "Z Project...", "projection=[Max Intensity]")
                proj_imp = WindowManager.getCurrentImage()
                if proj_imp is not None:
                    tile_imp.close()
                    tile_imp = proj_imp
            
            # Save tile (2D or projection)
            fs = FileSaver(tile_imp)
            if tile_imp.getNSlices() > 1:
                fs.saveAsTiffStack(tile_path)
            else:
                fs.saveAsTiff(tile_path)
            
            tiles.append((tile_filename, i, x_um, y_um, z_um))
            tile_imp.close()
        
        # Don't close reader here - managed by caller
        return tiles
    
    except Exception as e:
        log(u"  ERROR extracting tiles: {}".format(e))
        import traceback
        traceback.print_exc()
        return []

def create_tile_configuration(tiles, config_path, px_size):
    """Create TileConfiguration.txt for stitching plugin"""
    try:
        with open(config_path, 'w') as f:
            f.write("# Define the number of dimensions we are working on\n")
            f.write("dim = 2\n\n")
            
            for tile_filename, idx, x_um, y_um, z_um in tiles:
                # Convert µm to pixels
                x_px = x_um / px_size
                y_px = y_um / px_size
                
                f.write("{}; ; ({:.2f}, {:.2f})\n".format(tile_filename, x_px, y_px))
        
        return True
    except Exception as e:
        log(u"  ERROR creating tile configuration: {}".format(e))
        return False

def run_stitching_plugin(temp_dir, config):
    """Run ImageJ stitching plugin"""
    verbose = config.get('verbose', False)
    
    try:
        tile_config = os.path.join(temp_dir, "TileConfiguration.txt")
        
        # Build stitching command
        params = (
            "type=[Positions from file] "
            "order=[Defined by TileConfiguration] "
            "directory=[{}] "
            "layout_file=[TileConfiguration.txt] "
            "fusion_method=[Linear Blending] "
            "regression_threshold=0.30 "
            "max/avg_displacement_threshold=2.50 "
            "absolute_displacement_threshold=3.50 "
            "compute_overlap "
            "subpixel_accuracy "
            "computation_parameters=[Save memory (but be slower)] "
            "image_output=[Fuse and display]"
        ).format(temp_dir)
        
        if verbose:
            log(u"  [VERBOSE] Running stitching plugin...")
        
        IJ.run("Grid/Collection stitching", params)
        
        # Get result
        result_imp = WindowManager.getCurrentImage()
        if result_imp is None:
            log(u"  ERROR: Stitching plugin did not produce an image")
            return None
        
        if verbose:
            log(u"  [VERBOSE] Stitching complete: {} x {} x {}".format(
                result_imp.getWidth(), result_imp.getHeight(), result_imp.getNSlices()))
        
        return result_imp
    
    except Exception as e:
        log(u"  ERROR in stitching: {}".format(e))
        import traceback
        traceback.print_exc()
        return None

def process_czi_file(czi_path, config):
    """Process single CZI file with complete pipeline"""
    verbose = config.get('verbose', False)
    base_name = os.path.splitext(os.path.basename(czi_path))[0]
    
    log(u"")
    log(u"[1/1] Processing: {}".format(os.path.basename(czi_path)))
    
    start_time = time.time()
    
    # Create temp directory
    temp_dir = os.path.join(config['output_dir'], "temp_tiles_{}".format(int(time.time())))
    if not os.path.exists(temp_dir):
        os.makedirs(temp_dir)
    
    try:
        # ====================================================================
        # CRITICAL: SINGLE-PASS METADATA EXTRACTION
        # Extract pixel size, ALL positions, and colors in ONE operation
        # ====================================================================
        
        if verbose:
            log(u"  [VERBOSE] Opening file and extracting metadata...")
        
        metadata = MetadataTools.createOMEXMLMetadata()
        reader = ImageReader()
        reader.setMetadataStore(metadata)
        reader.setId(czi_path)
        accessor = OMEMetadataAccessor(reader, verbose=verbose)
        
        # Extract ALL metadata at once
        px_size = get_pixel_size(accessor, series=0)
        if not px_size:
            px_size = 0.345  # Fallback
        
        all_positions = parse_all_stage_positions_from_xml(accessor._ome_xml)
        
        if verbose:
            log(u"  [VERBOSE] Single-pass metadata extraction complete:")
            log(u"    Pixel size: {} µm".format(px_size))
            log(u"    Positions: {} StageLabels parsed from OME-XML".format(len(all_positions)))
            log(u"    Colors: Cached in accessor for later use")
        
        # Extract tiles using cached metadata
        log(u"  Extracting tiles...")
        tiles = extract_tiles_and_positions(czi_path, temp_dir, config, reader, accessor, px_size, all_positions)
        
        if not tiles or len(tiles) == 0:
            log(u"  ERROR: No tiles extracted")
            reader.close()
            return
        
        if len(tiles) == 1:
            # Single tile - just apply metadata
            log(u"  Single tile - skipping stitching")
            tile_path = os.path.join(temp_dir, tiles[0][0])
            imp = IJ.openImage(tile_path)
            
            # Apply calibration
            cal = imp.getCalibration()
            cal.pixelWidth = px_size
            cal.pixelHeight = px_size
            cal.setUnit("um")
            imp.setCalibration(cal)
            log(u"  Calibration: {} {}m/pixel".format(px_size, MICRO))
            
            # Apply colors
            if imp.getNChannels() > 1:
                imp = apply_channel_luts(imp, accessor, series=0)
        else:
            # Multi-tile - stitch
            log(u"  Creating tile configuration...")
            create_tile_configuration(tiles, os.path.join(temp_dir, "TileConfiguration.txt"), px_size)
            
            log(u"  Stitching {} tiles...".format(len(tiles)))
            imp = run_stitching_plugin(temp_dir, config)
            
            if imp is None:
                log(u"  ERROR: Stitching failed")
                reader.close()
                return
            
            # Apply calibration
            cal = imp.getCalibration()
            cal.pixelWidth = px_size
            cal.pixelHeight = px_size
            cal.setUnit("um")
            imp.setCalibration(cal)
            log(u"  Calibration applied: {} {}m/pixel".format(px_size, MICRO))
            
            # Apply colors
            if imp.getNChannels() > 1:
                imp = apply_channel_luts(imp, accessor, series=0)
        
        # Close reader
        reader.close()
        
        # Set title
        imp.setTitle(base_name + "_stitched")
        
        # Show and/or save
        if config.get('show_result', True):
            imp.show()
            log(u"  Result displayed")
        
        if config.get('save_result', True):
            output_path = os.path.join(config['output_dir'], base_name + "_stitched.tif")
            fs = FileSaver(imp)
            if imp.getNSlices() > 1:
                fs.saveAsTiffStack(output_path)
            else:
                fs.saveAsTiff(output_path)
            log(u"  Saved: {}".format(os.path.basename(output_path)))
        
        elapsed = time.time() - start_time
        log(u"  Complete! ({:.1f} seconds)".format(elapsed))
    
    except Exception as e:
        log(u"  ERROR: {}".format(e))
        import traceback
        traceback.print_exc()
    
    finally:
        # Cleanup
        if config.get('cleanup_temp', True):
            try:
                if os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
                    if verbose:
                        log(u"  [VERBOSE] Cleaned up temp directory")
            except:
                pass

# ==============================================================================
# PART 4: MAIN DIALOG AND EXECUTION
# ==============================================================================

def main():
    """Main entry point"""
    
    log(u"")
    log(u"SPECIALISED CZI STITCHER v36.3")
    log(u"Single-file standalone with complete stitching")
    log(u"Core: LUTs + Scaling + Positions + Stitching + Jingle")
    log(u"")
    
    # Create dialog
    gd = GenericDialog("CZI Stitcher v36.3")
    gd.addMessage("=== DIRECTORIES ===")
    gd.addDirectoryField("Input (CZI files):", os.path.expanduser("~"), 50)
    gd.addDirectoryField("Output:", os.path.expanduser("~"), 50)
    
    gd.addMessage("\n=== OPTIONS ===")
    gd.addCheckbox("Show stitched result", True)
    gd.addCheckbox("Save stitched result", True)
    gd.addCheckbox("Cleanup temp files", True)
    gd.addCheckbox("Verbose mode (detailed progress)", False)
    gd.addCheckbox("Play completion jingle", False)
    
    gd.showDialog()
    
    if gd.wasCanceled():
        return
    
    # Get parameters
    input_dir = gd.getNextString()
    output_dir = gd.getNextString()
    show_result = int(gd.getNextBoolean()) == 1
    save_result = int(gd.getNextBoolean()) == 1
    cleanup_temp = int(gd.getNextBoolean()) == 1
    verbose = int(gd.getNextBoolean()) == 1
    play_jingle = int(gd.getNextBoolean()) == 1
    
    # Validate directories
    if not os.path.isdir(input_dir):
        IJ.error("Input directory does not exist")
        return
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Build config
    config = {
        'input_dir': input_dir,
        'output_dir': output_dir,
        'show_result': show_result,
        'save_result': save_result,
        'cleanup_temp': cleanup_temp,
        'verbose': verbose,
        'play_jingle': play_jingle
    }
    
    # Find CZI files
    czi_files = [f for f in os.listdir(input_dir) if f.lower().endswith('.czi')]
    
    if len(czi_files) == 0:
        IJ.error("No CZI files found in input directory")
        return
    
    log(u"============================================================")
    log(u"STITCHING SESSION START")
    log(u"============================================================")
    log(u"Input:  {}".format(input_dir))
    log(u"Output: {}".format(output_dir))
    log(u"")
    
    if verbose:
        log(u"[VERBOSE] Configuration:")
        log(u"  Show result: {}".format(show_result))
        log(u"  Save result: {}".format(save_result))
        log(u"  Cleanup temp: {}".format(cleanup_temp))
        log(u"  Jingle: {}".format(play_jingle))
        log(u"")
    
    log(u"Found {} CZI file(s)".format(len(czi_files)))
    
    # Process files
    session_start = time.time()
    
    for czi_file in czi_files:
        czi_path = os.path.join(input_dir, czi_file)
        process_czi_file(czi_path, config)
    
    session_elapsed = time.time() - session_start
    
    log(u"")
    log(u"============================================================")
    log(u"ALL FILES PROCESSED")
    log(u"============================================================")
    log(u"Total time: {:.1f} seconds".format(session_elapsed))
    log(u"")
    
    # Play jingle if enabled
    if play_jingle:
        try:
            play_clear_jingle()
            log(u"Processing complete!")
        except:
            log(u"Processing complete! (jingle failed)")
    else:
        log(u"Processing complete!")

# Run main
if __name__ == "__main__" or __name__ == "__builtin__":
    main()
