# SPECIALISED CZI STITCHER v35.0 - CORE FEATURES ONLY
# Clean rebuild focusing on:
# 1. LUT/Color detection & application from OME-XML
# 2. Pixel size scaling (correct 0.345 not 3.45)
# 3. Completion jingle when enabled
#
# Built on proven ome_metadata_accessor.py module for clean OME-XML access

import os, time, shutil
from java.lang import System
from java.awt import Color
from ij import IJ, ImagePlus, CompositeImage
from ij.plugin import HyperStackConverter
from ij.process import LUT
from loci.plugins import BF
from loci.plugins.in import ImporterOptions
from ij.gui import GenericDialog
from ij.io import FileSaver

# Import our clean metadata accessor
try:
    from ome_metadata_accessor import OMEMetadataAccessor
    HAS_ACCESSOR = True
except:
    HAS_ACCESSOR = False
    IJ.log("Warning: ome_metadata_accessor.py not found - using fallback methods")

MICRO = u"\u00b5"

def log(msg):
    """Simple logging helper"""
    IJ.log(u"[CZI Stitcher v35] {}".format(msg))

def ensure_unicode(s):
    """Convert any string to unicode safely"""
    if s is None:
        return None
    if isinstance(s, unicode):
        return s
    if hasattr(s, 'toString') and not isinstance(s, (str, bytes)):
        return unicode(s.toString())
    if isinstance(s, str):
        try:
            return s.decode('utf-8', 'replace')
        except:
            pass
    try:
        return unicode(s)
    except:
        return u""

def apply_channel_luts(imp, accessor, series=0):
    """
    Apply channel colors from OME-XML metadata to CompositeImage
    
    Args:
        imp: ImagePlus (must be CompositeImage)
        accessor: OMEMetadataAccessor instance
        series: Series index (default 0)
    
    Returns:
        Modified ImagePlus with LUTs applied
    """
    if not isinstance(imp, CompositeImage):
        log(u"Image is not CompositeImage - cannot apply LUTs")
        return imp
    
    if not HAS_ACCESSOR:
        log(u"No metadata accessor - skipping LUT application")
        return imp
    
    try:
        channel_count = accessor.get_channel_count(series)
        if not channel_count:
            log(u"Could not determine channel count")
            return imp
        
        log(u"Applying LUTs for {} channels...".format(channel_count))
        
        for ch_idx in range(channel_count):
            # Get channel info
            ch_name = accessor.get_channel_name(series, ch_idx) or u"Channel {}".format(ch_idx + 1)
            ch_color_rgb = accessor.get_channel_color(series, ch_idx)
            
            if ch_color_rgb:
                r, g, b = ch_color_rgb
                log(u"  Channel {}: {} - RGB({}, {}, {})".format(ch_idx + 1, ch_name, r, g, b))
                
                # Create LUT from RGB color
                lut_r = [0] * 256
                lut_g = [0] * 256
                lut_b = [0] * 256
                
                for i in range(256):
                    lut_r[i] = (r * i) // 255
                    lut_g[i] = (g * i) // 255
                    lut_b[i] = (b * i) // 255
                
                # Apply LUT to channel (ImageJ uses 1-based indexing)
                imp.setC(ch_idx + 1)
                imp.setLut(LUT.createLutFromColor(Color(r, g, b)))
            else:
                log(u"  Channel {}: {} - No color metadata, using default".format(ch_idx + 1, ch_name))
        
        imp.setC(1)  # Reset to first channel
        imp.updateAndDraw()
        log(u"LUTs applied successfully")
        
    except Exception as e:
        log(u"Error applying LUTs: {}".format(ensure_unicode(str(e))))
    
    return imp

def get_pixel_size(accessor, series=0):
    """
    Get pixel size in micrometers from OME-XML metadata
    
    Args:
        accessor: OMEMetadataAccessor instance
        series: Series index (default 0)
    
    Returns:
        Pixel size in µm, or None if not found
    """
    if not HAS_ACCESSOR:
        return None
    
    try:
        px_um = accessor.get_physical_size_x(series)
        if px_um and 0.01 <= px_um <= 50.0:  # Sanity check: 10nm to 50µm
            log(u"Pixel size from OME-XML: {} {}m".format(px_um, MICRO))
            return px_um
        else:
            log(u"Pixel size out of range or not found: {}".format(px_um))
            return None
    except Exception as e:
        log(u"Error reading pixel size: {}".format(ensure_unicode(str(e))))
        return None

def stitch_tiles(input_dir, output_dir, config):
    """
    Core stitching function - ONLY uses ome_metadata_accessor.py for metadata
    
    Args:
        input_dir: Directory containing CZI files
        output_dir: Directory for output files
        config: Dictionary with settings
    """
    log(u"=" * 60)
    log(u"STITCHING SESSION START")
    log(u"=" * 60)
    log(u"Input:  {}".format(ensure_unicode(input_dir)))
    log(u"Output: {}".format(ensure_unicode(output_dir)))
    log(u"")
    
    if not HAS_ACCESSOR:
        log(u"ERROR: ome_metadata_accessor.py is required!")
        log(u"Place ome_metadata_accessor.py in Fiji's plugins or scripts directory")
        return
    
    # Get list of CZI files
    czi_files = []
    try:
        for f in os.listdir(input_dir):
            if f.lower().endswith('.czi'):
                full_path = os.path.join(input_dir, f)
                czi_files.append(full_path)
    except Exception as e:
        log(u"Error listing files: {}".format(ensure_unicode(str(e))))
        return
    
    if not czi_files:
        log(u"No CZI files found in input directory")
        return
    
    log(u"Found {} CZI file(s)".format(len(czi_files)))
    log(u"")
    
    # Process each file
    for idx, czi_path in enumerate(czi_files):
        log(u"[{}/{}] Processing: {}".format(idx + 1, len(czi_files), os.path.basename(czi_path)))
        
        try:
            # Import using Bio-Formats with stitching
            options = ImporterOptions()
            options.setId(czi_path)
            options.setStitchTiles(True)
            options.setOpenAllSeries(False)  # Only first series
            
            imps = BF.openImagePlus(options)
            if not imps or len(imps) == 0:
                log(u"  ERROR: Failed to open file")
                continue
            
            imp = imps[0]
            log(u"  Opened: {} x {} x {} (C x Z x T)".format(
                imp.getNChannels(), imp.getNSlices(), imp.getNFrames()))
            
            # ===== ONLY USE ome_metadata_accessor.py FOR METADATA =====
            try:
                # Create Bio-Formats reader
                from loci.formats import ImageReader
                reader = ImageReader()
                reader.setId(czi_path)
                
                # Create metadata accessor - THIS IS THE ONLY METADATA CODE
                accessor = OMEMetadataAccessor(reader)
                
                # Feature 1: Get correct pixel size (0.345 not 3.45)
                px_size = get_pixel_size(accessor, series=0)
                if px_size:
                    cal = imp.getCalibration()
                    cal.pixelWidth = px_size
                    cal.pixelHeight = px_size
                    cal.setUnit("um")
                    imp.setCalibration(cal)
                    log(u"  Calibration: {} {}m/pixel".format(px_size, MICRO))
                
                # Feature 2: Apply channel colors (LUTs) if multi-channel
                if imp.getNChannels() > 1 and config.get('apply_luts', True):
                    log(u"  Converting to CompositeImage...")
                    imp = HyperStackConverter.toHyperStack(
                        imp, imp.getNChannels(), imp.getNSlices(), imp.getNFrames(), 
                        "grayscale", "Composite")
                    
                    imp = apply_channel_luts(imp, accessor, series=0)
                
                reader.close()
                
            except Exception as e:
                log(u"  WARNING: Metadata processing failed: {}".format(ensure_unicode(str(e))))
                import traceback
                log(u"  {}".format(ensure_unicode(traceback.format_exc())))
            # ===== END METADATA CODE =====
            
            # Show result if requested
            if config.get('show_result', True):
                imp.show()
                log(u"  Displaying result")
            
            # Save result if requested
            if config.get('save_result', False):
                output_name = os.path.splitext(os.path.basename(czi_path))[0] + "_stitched.tif"
                output_path = os.path.join(output_dir, output_name)
                saver = FileSaver(imp)
                if saver.saveAsTiff(output_path):
                    log(u"  Saved: {}".format(output_name))
                else:
                    log(u"  ERROR: Failed to save")
            
            # Close if not showing
            if not config.get('show_result', True):
                imp.close()
            
            log(u"  Complete!")
            log(u"")
            
        except Exception as e:
            log(u"  ERROR: {}".format(ensure_unicode(str(e))))
            import traceback
            log(u"  {}".format(ensure_unicode(traceback.format_exc())))
            log(u"")
    
    log(u"=" * 60)
    log(u"ALL FILES PROCESSED")
    log(u"=" * 60)
    
    # Play jingle if enabled
    if config.get('play_jingle', False):
        try:
            IJ.run("Play Startup Sound", "")
            log(u"Processing complete!")
        except:
            log(u"Processing complete! (jingle not available)")

def show_dialog():
    """Show configuration dialog and return settings"""
    
    gd = GenericDialog("CZI Stitcher v35.0 - Core Features")
    
    gd.addMessage("=== DIRECTORIES ===")
    gd.addDirectoryField("Input directory:", "")
    gd.addDirectoryField("Output directory:", "")
    
    gd.addMessage("")
    gd.addMessage("=== CORE FEATURES ===")
    gd.addCheckbox("Apply channel colors from OME-XML", True)
    gd.addCheckbox("Show stitched result", True)
    gd.addCheckbox("Save stitched result", False)
    gd.addCheckbox("Play completion jingle", True)
    
    gd.showDialog()
    
    if gd.wasCanceled():
        return None
    
    config = {
        'input_dir': gd.getNextString().strip(),
        'output_dir': gd.getNextString().strip(),
        'apply_luts': int(gd.getNextBoolean()) == 1,
        'show_result': int(gd.getNextBoolean()) == 1,
        'save_result': int(gd.getNextBoolean()) == 1,
        'play_jingle': int(gd.getNextBoolean()) == 1
    }
    
    return config

def main():
    """Main entry point"""
    log(u"")
    log(u"SPECIALISED CZI STITCHER v35.0")
    log(u"Core Features: LUTs + Scaling + Jingle")
    log(u"")
    
    # Check for metadata accessor
    if not HAS_ACCESSOR:
        log(u"WARNING: ome_metadata_accessor.py not found!")
        log(u"Place ome_metadata_accessor.py in the same directory as this script")
        log(u"")
    
    # Show dialog
    config = show_dialog()
    if not config:
        log(u"Cancelled by user")
        return
    
    # Validate directories
    if not config['input_dir'] or not os.path.isdir(config['input_dir']):
        IJ.error("Invalid input directory")
        return
    
    if not config['output_dir']:
        config['output_dir'] = config['input_dir']
    
    if not os.path.isdir(config['output_dir']):
        try:
            os.makedirs(config['output_dir'])
        except:
            IJ.error("Could not create output directory")
            return
    
    # Run stitching
    start_time = time.time()
    stitch_tiles(config['input_dir'], config['output_dir'], config)
    elapsed = time.time() - start_time
    
    log(u"")
    log(u"Total time: {:.1f} seconds".format(elapsed))
    log(u"")

if __name__ == "__main__" or __name__ == "__builtin__":
    main()
